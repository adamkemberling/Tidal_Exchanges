---
title: "Intro to R"
author: "LGCarlson"
date: "6/1/2020"
output: html_document
editor_options: 
  chunk_output_type: inline
---

## Welcome to R!

This file is an R Markdown document (.Rmd) which can only be opened in R Studio.Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

The title/author/date/output fields above are part of the _YAML header_, which tells the Markdown document how to format the output when you "Knit" the document (yarn button in top control bar). A YAML header is always surrounded by "---". When you click the _Knit_ button, a document will be generated that includes both written content as well as the output of any embedded R code chunks within the document. 

You can treat the _white space_ in this document almost like a Word document. Use it to add metadata or document your process. 

You can use html codes to format the text in the white space. For example, you can _italicize_ or **bold** regular text, add [hyperlinks](https://wordpress.com/support/markdown-quick-reference/) and create various level headers:

# Header 1
## Header 2
### Header 3 
#### Header 4 ####
##### Header 5 #####
###### Header 6 ######

You can also create bulleted or numbered lists:

1. Item
2. Item
   * Subitem
   * Subitem  
3. Item

The _gray_ areas are called "embedded code chunks." You can add a code chunk using the green + "Insert" button on the top control bar, or by typing three backticks (`). You must also close to chunk with three backticks to run the chunk. The "r" in {brackets} at the top of the code chunks tells R Studio that you're writing in the R programming language (you can also write in other languages, but we won't worry about that for now). 

You can run the chunk by highlighting the code and pressing the "Run" button on the top control bar. You can also press the green arrow at the far right of the code chunk to run it. 

The code will run in the console (bottom left panel) and the code's output will be displayed inline or embedded in the active script (top left panel... and probably where you're reading this). 

Objects created by the code will be saved into the Environment (top right panel). 

The bottom right panel has a few useful functionalities including allowing you to install packages (non-programmatically) and view which packages you already have installed (Packages Tab), search the help menu/documentation (Help Tab), and view plots you created in the code (Viewer Tab). 

Base R has >2000 pre-loaded functions, so without doing anything else, you can actually do a lot in R! But there are thousands of packages that can also be installed and use in R, which gives you endless possibilities to explore. 

Let's practice installing a package...


## Installing and loading packages into your library

```{r setup}
# You can also write documentation (non-code) in the code chunk, but you must # it out (will turn green)

# This is the setup chunk (chunk names go after the language in the brackets)

knitr::opts_chunk$set(echo = TRUE)

# First, we will install a package using code. You only need to install a package once. After tidyverse is installed, you can delete this line of code or # it out (will not be run)

install.packages("tidyverse")

# Once the package is installed, you must load it into your library to be able to use it in the code. This must be done in each new code you write

library(tidyverse)

```


_tidyverse_ is actually a collection of packages. The packages installed by tidyverse (tidyr, dplyr, readr, purrr, stringr, forcats, ggplot, and more!) contain the most useful (and most widely used) functions in R, outside of those functions which come as part of the base R package (you don't need to install this). We will cover many of these functions later on.



## Reading in data

* To read in data, you can use the read_csv() function from the readr package. 

* You will have to change the "working directory" to the location where you saved the data

* Use the <- (carrot + dash = arrow) to assign something to an object that will be saved in your environment

```{r}
penguins<-read_csv("penguins_data.csv")
```

The text below the code gives you information about what happened when you ran the code. Sometimes you'll get an error or warning message, but in this case, the output is telling you what variable types it assigned to each column. 

Now that you've run this code chunk, you'll be able to see "penguins" in your environment (top right). Let's see what the data looks like inline. 

```{r}
# To look at the entire dataset, just rerun the "penguins" object
penguins
```

R Markdown gives you a preview of the dataset and allows you to look through the whole dataset using the "Next" button at the bottom of the table. Markdown also shows you what type of data is contained in each column below the column name (i.e., <chr> or <dbl>). 



## What is a function?

Functions are “self contained” modules of code that accomplish a specific task. Functions usually take in some sort of data structure (value, vector, dataframe etc.), process it, and return a result.

The general usage for a function is the name of the function followed by parentheses:

> function_name(input)

The input(s) are called arguments, which can include:

* The physical object (any data structure) on which the function carries out a task
* specifications that alter the way the function operates (e.g. options)

However, not all functions take arguments, for example:

```{r}
getwd()
```


However, most functions can take several arguments. If you don’t specify a required argument when calling the function, you will either receive an error or the function will fall back on using a default.

The defaults represent standard values that the author of the function specified as being “good enough in standard cases”. An example would be what symbol to use in a plot. However, if you want something specific, simply change the argument yourself with a value of your choice.

Functions are often called either from base R or a package you've loaded into your library. You can also write your own functions. We'll get to that later. 


## Using functions

Let's look at a few common base functions.

**class** is a function that allows you to see what type of object something is. In this case, penguins is a "tibble" or "data frame" (same thing).

```{r}
class(penguins)
```

What is the argument (or input) for class()? 

We used "penguins" here, but you could use any object in your r environment. 

**str** is a function that allows you to look at the structure of a dataframe (or other type of data object in R). It's always a good idea to use str() to get an idea of what types of values are included in your data.

```{r}
str(penguins)
```

**names** is a function that returns the column names of a dataframe (or other type of data object in R)

```{r}
names(penguins)
```

**help** is a function that returns the R documentation for a funtion in the Help tab (bottom right). The argument is any function from base or a package you have installed.

```{r}
help(names)
```



**c** is a function that combines values into a vector or list. We will use it here to create a numeric vector and test out some other functions

Again, use the <- symbols to assign a name to some object you're creating. Oftentimes, you'll use functions to create a new object.

```{r}
my_vector <- c(5,2,8,1,9,5)
```

Here's what we get if we run the functions we know already on this object.

```{r}
class(my_vector)
str(my_vector)
names(my_vector)
```

Now, let's run some basic mathematical functions since we have a numeric vector. 

* **mean** - calculates mean (average) of a vector

* **max** - calculates maximum value of a vector

* **sum** - calculates sum of all values in a vector

* **length** - returns the length of a vector (total number of values)

* **sort** - sorts values in a vector numerically

```{r}
mean(my_vector)
max(my_vector)
sum(my_vector)
length(my_vector)
sort(my_vector)
```

Do you agree with the outputs?



## Specifying additional arguments or options within functions

Sometimes functions have additional arguments that change their behavior. If you don't specify additonal arguments or options, R will use the default settings. 

For the **sort** function we just learned, there are actually two arguments. Let's see what they are by opening the documentation using help().


```{r}
help(sort)
```

Now we know that in addition to the vector, sort also includes an argument called "decreasing" for which the default setting is "FALSE". Thus, items are sorted in ascending order by default. If we want to sort in decreasing order, we can set this argument to "TRUE".

```{r}
sort(my_vector, decreasing = TRUE)
```

You don't have to specify the argument name (i.e., x= or decreasing=), so long as you put the arguments in the correct order. For example, this function works just as well


```{r}
sort(my_vector, TRUE)
```




## Types of objects in R

### Scalars

Scalars hold a single element or atomic value – numeric, character, etc

*Note: Character elements must be enclosed by quotation mark: either " or '


```{r}
my_col<-'red'
my_num<-13

my_col; my_num
```

```{r}
class(my_col)
class(my_num)
```

### Vectors

Vectors hold multiple elements all of the same class (can’t mix numbers and character values in same vector)


```{r}
year_vec<-c(1968, 1981, 1996)
org_vec<-c('GMRI', 'NMFS', 'DFO')

year_vec;org_vec
```

Vectorized operations work on numeric vectors (i.e., you can do math on vectors)

```{r}
year_vec+1
```


### Dataframes/tibbles

2-dimensional data storage type, similar to an Excel spreadsheet

Different columns (which are each vectors) can have different classes

To create a dataframe or tibble, you can use the function data.frame() or tibble() where the arguments are the column names = a vector. You can either refer to a previously created vector (i.e., org_vec) below, or create on within the function using c().


```{r}
my_df<-data.frame(Org = org_vec, Year = c(2000,2000,2000))
my_df
```

_Note:_ There are other types of objects you can create in R such as matrices, lists, and arrays, but for now, you can get away with using mostly vectors and dataframes.


## Indexing

An important aspect of working with R objects is knowing how to “index” them Indexing means selecting a subset of the elements in order to use them in further analysis or possibly change them Here we focus just on three kinds of vector indexing: positional, named reference, and logical Any of these indexing techniques works the same for all classes of vectors

Here are the most common types of index you'll use:

* []: access values within a vector OR rows, columns, or values within a dataframe, matrix, etc

* $: access columns of a dataframe


```{r}
# access value 2 in a vector
year_vec[2]

# access the value in row 1, column 1 of a dataframe
my_df[1,1]

```

Rows using brackets

```{r}
# access row 1 in a dataframe (number goes after the comma)
my_df[1,]

```


Columns using brackets:

```{r}
# access column 1 in a dataframe (number goes after the comma)
my_df[,1]

my_df
```

You can also access columns by name rather than number by using the dollar sign indexing. If you type a dataframe's name followed by a $, R will suggest the column names. Because rows aren't named, you can do the same thing for them.

```{r}
my_df$Org

```

You may want to use indexing to create new objects (vector in this case). For example:

```{r}
bill_lengths<-penguins$bill_length_mm

class(bill_lengths)
head(bill_lengths,20)
```

**head** is a new function that returns the first "n" values in an object. The primary argument is any R object. The default for n=10, but here I specified 20.



## Exploratory data analysis

For this section, we will begin using functions from the tidyverse packages. To connect these functions, we will use an operator called the pipe that looks like this %>% 

This operator will forward a value, or the result of an expression, into the next function call/expression. For instance a function to check the structure of data can be written as:


```{r}
str(my_df) 

#or

my_df %>% str()
```
Lets just remind ourselves what the penguins dataset looks like:

```{r}
penguins
```


### Data wrangling

**filter** - Often we want to work with particular parts of data sets. The filter function from package dplyr allows us to filter (or subset) based on a specific set of criteria


```{r}
# filter by an exact condition, in this case, keep only species == "Gentoo"    *this is more often used for categorical variables but can be used on numeric variables as well (for example bill_length_mm == 46.1)

penguins %>% filter(species == "Gentoo")

```


*Note, you can also write the function this way:

filter(penguins,species == "Gentoo")

But the pipe operator becomes useful when running multiple functions in a row


```{r}
# filter by value (can be greater than, lesser than, or equal to)

penguins %>% filter(body_mass_g > 5000)
```


```{r}
# filter to remove by an exact condition, in this case, island != "Torgersen" Which means remove any penguins caught on Torgersen island, but keep all others

penguins %>% filter(island != "Torgersen")
```


```{r}
# filter out NA values (works for both characters and numbers)

penguins %>% filter(!is.na(sex))
```

**mutate** - adds new variables and preserves existing ones (unless you overwrite their name)

```{r}
# Perhaps we want to flipper length (in mm) to cm, we could add a new column to do this while doing math on the old column

penguins %>% mutate(flipper_length_cm = flipper_length_mm*0.1)
```


### Calculating summary statistics 

**group_by** - group by one or more variables
**summarize** - reduce multiple values down to a single value 

Calculate the mean bill length by species
```{r}
penguins %>% 
  group_by(species) %>% 
  summarise(mean_bill_length = mean(bill_length_mm, na.rm = T))
```

Calculate the mean and standard deviation of body mass by sex

```{r}
penguins %>% 
  group_by(sex) %>% 
  summarise(mean_mass = mean(body_mass_g, na.rm = T), 
            sd_mass = sd(body_mass_g, na.rm = T))
```
